The Technical Interview: Algorithms and Data Structures
Algorithm - a program that solves a problem.

Introduction and Efficiency

Efficiency: also called complexity - how well computer resources of time and space are used
Time: how long does the code take to run
Space: how much storage space does your code occupy

Notation of Efficiency - for both time and space efficiency:

Big O Notation: O(1), O(log(n), O(sqrt(n)) O(n), O(n * log(n)), O(n^2), O(n^3), etc.
where n is the length of the input to the function. (Size of list or data)

List-Based Collections:

Lists/Arrays:
Arrays: arrays have indices, numbered from 0 to n - 1
Insertion is O(n)

Linked Lists:
No indices. Each element knows something about the next element (that it is linked to)
In each element, you store a reference (the memory address) to the next element.
Insertion is O(1)

Stacks:
First in, last out. (aka Last in, first out.)
Push to add element to top of stack, pop to remove element from top of stack.
Both push and pop run in constant time, O(1)

Queues:
First in, first out.
Add element to tail - Enqueue
Remove element from head - Dequeue
Look at head element but don't remove it - Peek
Like a linked list. Save references to head and tail so you can look them both up in O(1), constant time.
Priority Queue: assign each element a priority when you insert it into the Queue. This breaks the rules a bit because when you remove, you remove by priority first. If you have two or more with same priority, however, you remove the oldest element first.


Searching and Sorting:
Binary Search:
Look at middle element first, if value you seek is larger, look to right, if smaller, look to left. Again, look at middle of this new array to see if sought value is larger or smaller.
Efficiency of binary search: O(log(n)) (logarithmic)

Recursion

Bubble Sort

Merge Sort

Quick Sort

Maps and Hashing

Maps

Hashing

Collisions

Hashing Conventions

Trees

Trees

Tree Traversal

Binary Trees

Binary Search Trees

Heaps

Self-Balancing Trees

Graphs

Graphs

Graph Properties

Graph Representation

Graph Traversal

Graph Paths

Case Studies in Algorithms

Shortest Path Problem

Knapsack Problem

Traveling Salesman Problem

Technical Interview Tips

Mock Interview Breakdown

Additional Tips

Practice with Pramp

Next Steps
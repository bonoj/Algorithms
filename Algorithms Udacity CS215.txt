Graphs / Networks

Node / Vertices
Edges /Links: link nodes
Degree of a node is number of edges connected to that node.

Eulerian path - path through a graph along the edges that only hits each edge once while visiting all the nodes in a graph.

Eulerian Tour - special kind of Eulerian path where you start and end at the same node.

Divide and Conquer:
Break a problem into roughly equal sized subproblems, solve them separately, and then combine results.

Types of Networks:

Chain Network: chains do not have cycles
o----o-----o-----o-----o
e.g. 5 nodes, 4 edges.          m = n - 1       m edges with n nodes


Ring Network: rings must have cycles
o----o-----o-----o-----o
|----------------------|
e.g. 5 nodes, 5 edges.               m = n          m edges with n nodes

Grid Network
n = 20, m = 15 + 16 = 31


Complete Set:
f(n) is in o(g(n)) == f(n) < g(n)               little o
f(n) is in O(g(n)) == f(n) <= g(n)              Big O
f(n) is in big theta(g(n)) == f(n) = g(n)       Big Theta
f(n) is in big omega(g(n)) == f(n) >= g(n)      Big Omega
f(n) is in little omega(g(n)) == f(n) > g(n)   little omega

Planar Graphs: Graph drawn on a plane such that the edges don't cross.

    R3

o------o---\
|      |    \
|   R1 | R2  o
|      |    /
o------o---/

n = 5, m = 6, r = 3         where n is a node, m is an edge, and r is a region.
Relationship between n, m, and r: For any planar, n - m + r = 2

Growth rate of edges in planar graph:
every region must be bounded by at least 3 edges.
so with n - m + r = 2 in mind, 3 * regions (3r) must be less than 2 * edges (2m)
3r <= 2m, r <= 2/3 * m
m + 2 = n + r <= n + 2/3 * m
3m + 6 <= 3n + 2m
m <= 3n - 6 which is in BigTheta(n) (linear)

Recap:
For chain, ring, grid, and planar graphs, the relationship of m with regards to n is in BigTheta(n). That is, their growth as n nodes increases is linear - f(n) = g(n)


Complete Graph: aka Clique
Each node in a graph is connected to each other node, e.g. a 5 node graph ends up with a star in a pentagon, 5 nodes and 10 edges.

m = n * (n-1) / 2 which is in BigTheta(n^2). That is, the growth relationship of m with regards to n is quadratic.

Tree Graphs:
-is connected
-has no cycles or loops.


Randomly Generated Graphs:
Erdos - Renyi Model
n nodes
p connectivity probability (coin flip, for instance)
1. Generate nodes.
2. For each node pair, i,j
connect i,j with probability p

Some Recursive Graphs:
1. n nodes
2. create graph on n/2 nodes
3. create graph on other n/2 nodes
4. generate edges between the two smaller graphs
5. return graph

Recurrence Relations
T: # of edges
T(1) = 0
T(n) = 2T(n/2) + 1

Tree graphs grow linearly. m = 2n = BigTheta(n)


GRAPH RECAP:
Recurrence                              Graphs                          Edge Growth
T(n) = 2T(n/2) + 1                      tree, chain                     BigTheta(n)
T(n) = 2T(n/2) + BigTheta(n^2)          clique, dense graph             BigTheta(n^2)
T(n) = 2T(n/2) + BigTheta(n)            hypercube, tangled hypercube    BigTheta(n * log(n))

Star Network:
has a single node in the center
that is connected to all the rest of the nodes in the graph directly

Clustering coefficients:

Clustering coefficient of a node:
CC(v): v: a node, Kv: its degree, Nv: number of links between neigbours of v
CC(v) = 2Nv / (Kv * (Kv -1))

The clustering coefficient is the fraction of possible interconnections:
                                0 <= CC(v) <= 1
Star (no neighbours connected)                  clique (all neighbours connected)

Clustering coefficient of a graph:
The average of the clustering coefficients CC(v) of the nodes in the graph.


Connected Components
-is everything connected?
-is a set of nodes isolatd?
-can all nodes communicate?

Graph searching:

Depth First search: Search first as deep as possible (often with recursion) from an arbitrary starting point
Depth First without recursion:
-Grab the last element of an open list
-Mark any unmarked neighbors and add to open list
-Repeat until nothing is open

Choose starting point, create open list, append to end of list, check the last element's neighbors and pop it.

a-b-c-d-e-f-g
5-4-2-1-3-6-7



Breadth First search
Breadth First without recursion:
-Grab the first element of an open list
-Mark any unmarked neighbors and add to open list
-Repeat until nothing is open
a-b-c-d-e-f-g

Choose starting point, create open list, append to end of list, check the first element's neighbors and pop it.
